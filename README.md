# MIcrosha-My-Shell-

К файлу microsha.cpp подключена библиотека DKA.h ,позаимствованная с гитхаба.

В microsha.cpp   реализовано считывание с командной строки,и исполнение команд (некоторых )
В   DKA.cpp реализовано построение ДКА по РВ ,чтобы заюзать глоббинг в случае команды ls /*?fasdf?/ыв

Глоббинг реализован динамически : сначала находится множество имен принадлежащих регулярному выражению заданному в самом начале от корня (/regex1/....)или текущей дирректории (./regex1/......),далее по этим именам мы углубляемся в пространстве файлов и в полученном пространстве файлов ,ограниченном регулярным выражением
regex1 ,мы ищем подходящие под регулярное выражение regex2 , в итоге мы уже имеем все пути принадлежащие языку L(/regex1/regex2) , продолжаем до конца проходиться по /regex1/regex2/..../regexn. ( потом к полученному массиву последовательно применяется execvp())


Уверен,что тут есть много багов ,но работает приемлемо ,если писать ~адекватные вещи в командную строку.
Однако глоббинг работает ну очень долго , возможно было плохой идеей преобразовывать 
* в выражение (a|b|....|Z)*,  судя по всему нужно созать некоторый приинцип преобразования выражений типа *?ASSAD?as????*
 сразу в автомат (предположительно что-то похожее на построение КМП автомата ,ведь у нас строится огромный ДКА автомат , без минимизации)
 
 В программе при каждом некорректном запросе утекает 2 бита памяти, которые я не успел пофиксить, это определенно течет при 
 вызове функции char * temp = new char[buf.length()+1]; , пока пытался это отдебажить, получил программу ,в которой память уже не текла ,но уже не работающую при вызове коротких функций таких как pwd , echo,time , но работали те которые я отдельно считывал и исполнял.
 
 По сути нужно исправить функцию ,разбивающую  char* на отдельные слова и закидывающую все это в char**
